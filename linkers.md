# 第一章

## 1.1 计算机的基本概念

计算机系统由软件和硬件组成。 

最主要的硬件是三个：`CPU` `内存` `I/O`

对称多处理器时代：现在的计算机的CPU都是有多个物理核心的`SMP`

我们见到的软件主要是`application`和`development tools`。

软件是分层的。 
操作系统内核是最底层的，其上是运行时库，然后是应用程序。

    一些重要的概念：
    application
    interface
    run-time-library
    kernel 
    driver 
    hardware

层次之间需要相互通信，这就需要接口。
接口是精心设计的，尽量保持稳定不变。
**应用层程序**编写使用的**应用程序编程接口**(API)是运行时库提供的。
**运行时库**使用的接口是操作系统提供的**系统调用**。
系统调用接口一般以**软件中断**的方式提供。
**驱动程序**是**操作系统内核**的重要组成部分。
操作系统内核使用**硬件接口**提供的服务。
硬件接口的定义决定了驱动程序如何操作硬件。
操作系统和驱动程序的开发者通过阅读**硬件规格**和**硬件编程接口标准**来编写操作系统和驱动程序。

## 1.4 操作系统

操作系统的2个主要功能：`提供抽象的接口`、`管理系统的资源`。

计算机中的资源主要是`计算`、`存储`、`输入输出`。

### 1.4.1 尽量让CPU不要空转

计算资源是不应该被浪费的。

**监控程序**：负责调度准备就绪的程序获得CPU使用权.
这就是多道程序调度策略，是粗糙的策略。

不分轻重缓急是不好的，于是采取主动的策略一段时间之后放弃，这就是分时系统。

    multi programing
    time sharing system
    multi tasking
    process
    preemptive

操作系统接管一切资源，应用程序以进程的方式运行在一个比操作系统权限更低的级别。

操作系统有权暂停一个进程，让另一个进程运行，这就实现了抢占式的内核。

### 1.4.2 设备驱动程序

硬件之间千差万别，应用程序的编写人员不可能直接和硬件打交道。
驱动程序屏蔽了不同硬件之间的差异，硬件被抽象为一系列的概念。

**驱动程序**是内核的一部分，和内核运行在同一特权级别，但是又有一定的独立性。

**文件系统**管理数据在磁盘中的存储方式，是操作系统的重要组成部分。

应用程序要读取硬盘上的数据：
- 应用程序向文件系统发起`read系统调用`，
- 文件系统向硬盘的驱动程序发出请求，
- 驱动程序向硬盘发出`IO命令`

发送IO命令的最常见方式是读写IO寄存器。

## 1.5 内存不够了

如何将计算机上有限的物理内存分配给多个应用程序使用?

### 1.5.1 隔离

直接使用物理内存没有实现隔离、使用的效率低、运行的时候的地址不确定。

虚拟内存解决隔离的问题：每个程序有自己独立的虚拟地址空间。
关键的问题是如何实现虚拟地址和物理地址之间的映射。

### 1.5.2 分段

根据应用程序所需的地址空间的大小直接映射：分段。
分段解决了地址空间隔离的问题和重定位问题。
分段根据程序所需要的地址空间的大小来分割内存，这样粒度太大了，效率比较低。

### 1.5.3 分页

根据局部性原理，我们可以以更细的粒度来对内存进行分割与映射，这就是分页。

页的大小由硬件决定，或者硬件支持多种大小的页，操作系统做出选择。

    虚拟页 virtual page
    物理页 physical page
    磁盘页 disk page

虚拟存储的实现需要硬件的支持：MMU 将虚拟地址翻译成物理地址。

## 1.6 并发与线程

软件并发执行可以发挥多核CPU的性能优势。
多线程是软件并发执行的重要方法。

### 1.6.1 线程

`线程`是程序执行流的最小单元，也被成为轻量级进程。
一个进程由多个线程组成，线程共享进程的地址空间和一些进程级的资源，比如打开文件和信号。

线程私有的一些数据：局部变量，函数的参数、线程局部存储（栈、PC寄存器、线程局部存储数据）。
线程之间共享的进程的资源：全局变量，堆上的数据，函数里的静态变量，程序代码，打开的文件。

线程在SMP上运行可以实现真正的并发执行，但是线程数量多与CPU核心的数量之后就需要线程调度策略。

    thread schedule
    running
    ready
    waiting

线程通常拥有至少三种状态：运行、就绪、等待。
运行中的线程拥有一小段用于执行的时间，成为时间片。`time slice`

- 线程调度

不同操作系统中的线程调度算法，但都融入了优先级调度和轮转法的思想。
在具有优先级的调度系统中，每个线程都有自己的优先级。

线程可以分为：IO密集型线程、CPU密集型线程。

在优先级调度下，可能会出现饿死现象。因此调度系统需要提升过长时间得不到执行的线程的优先级。

线程优先级的改变一般有三种方式：

    用户指定优先级
    根据进入等待状态的频繁程度提升或降低优先级
    长时间得不到执行的线程提升优先级

- 可抢占线程与不可抢占线程

线程在时间片用尽之后，被强制剥夺执行的权力是可以抢占的线程。
早期系统是不可抢占线程，好处是线程调度的时候的执行时机是确定的，可以减少安全问题。

- Linux的多线程

Linux中的所有执行实体都被成为任务。
`task`概念上都类似于一个单线程的进程，具有内存空间、执行实体、文件资源。

Linux下创建新的任务的系统调用：
    
    fork 复制当前的进程。
    exec 使用新的可执行映像覆盖当前的可执行映像。
    clone 创建子进程并从指定位置开始执行。

fork产生新任务的速度非常快，因为fork并不复制原任务的内存空间，而是和原任务共享一个`写时复制`的内存空间。

### 1.6.2 线程安全

多线程程序在并发时数据的一致性非常重要。
多线程程序处于一个多变的环境之中，可访问的全局变量和堆数据随时都可能被其他的线程改变。

- 竞争与原子操作

单指令的操作可以原子化，这样在执行的时候就不会被打断。
更复杂的数据结构需要使用锁。

- 同步与锁

为了防止多个线程同时读写一个数据而产生不可预料的后果，我们需要对数据进行同步。
同步就是在一个线程访问数据未结束的时候，其他线程不能对这个数据进行访问。

锁是一种非强制的机制，线程在访问资源之前需要获取锁，访问之后释放锁。`lock` `acquire` `release`

二元信号量是最简单的一种锁，只有2个状态：占用和非占用。
适合只能被唯一一个线程独占访问的资源。

对于允许多个线程并发访问的资源，要使用多元信号量。 `semaphore`

互斥量和二元信号量相似，但是获取和释放只能是同一个线程。`mutex`

临界区`critical section`是比互斥量更加严格的同步手段。
互斥量和信号量对系统中的所有线程都是可见的。
临界区的作用范围和可见性仅限与本进程。

对于读取很多，写入很少的资源，使用读写锁来进行同步效率更高。
对于同一个锁，读写锁有两种获取方式，共享的和独占的。

条件变量是一个类似栅栏的同步手段，可以让很多线程同时等待一个事件的发生，事件发生之后，所有的线程可以同时恢复执行。

- 可重入与线程安全 `reentrant` 

一个函数被重入说明函数执行没有完成，被打断了。
可重入函数是重入后不会产生不良后果的函数。
一个可重入的函数可以再多线程环境下放心使用。

- 过度优化

因为编译器和CPU的优化，即使是正确地使用锁，也不一定能保证线程安全。

#### 多线程的内部情况

线程的并发执行是多处理器或操作系统调度来实现的。

用户态的线程和内核线程不是简单的一一对应的关系。

- 三种线程模型

最简单的模型是一对一模型，线程之间的并发也是真正的并发。
Linux中使用clone系统调用创建的线程就是一对一的线程。

多对一的线程模型是将多个用户线程映射到同一个内核线程上。
线程之间的切换由用户代码来执行，切换的速度比一对一线程模型要快得多。
多对一模型减小了上下文切换的开销，提供了近乎无限的线程数量。
但是一个用户进程的阻塞就会造成多个进程的阻塞，增加处理器核的数量也不会对性能提升带来明显帮助。

多对多模型结合了一对一和多对一的特点。

# 第二章 编译和链接

## 2.1 被隐藏的过程
集成开发环境`IDE`
通常把编译和链接合并在一起的过程成为构建：`build`

```shell
    gcc hello.c`
```

这个过程可以分解为4个过程：预处理、编译、汇编、链接

`prepressing` `compilation` `assembly` `linking`

### 2.1.1 预编译

预编译器`cpp`将头文件和源文件预编译成一个`i文件`：

```shell
    gcc -E hello.c -o hello.i
```

预编译器主要处理那些源代码中以`#`开头的的预处理指令：`#include` `#define`

预处理的时候加入了文件名和行号，保留了所有的编译器指令：`#prahma`

我们可以通过查看预编译后的文件来确定宏定义展开是否正确，头文件包含是否正确。

### 2.1.2 编译

编译是整个程序构建的核心部分，也是最复杂的部分。

编译过程是把预处理后的文件进行一系列的词法分析、语法分析、语言分析、优化，然后生产出相应的汇编代码文件。

编译原理里面具体介绍了编译过程的理论。可以通过这些命令得到汇编文件：

```shell
    gcc -S hello.i -o hello.s
    gcc -S hello.c -o hello.s
    cc1 hello.c
```

实际上`gcc`是一些后台程序的包装，会根据不同的参数要求去调用预编译编译程序`cc1`、汇编器`as`、链接器`ld`

### 2.1.3 汇编

汇编器将汇编代码翻译成机器可以执行的指令。
没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了。

```shell
    as hello.s -o hello.o
    gcc -c hello.s -o hello.o
    gcc -c hello.c -o hello.o
```

### 2.1.4 链接
    
链接将所有的目标文件链接成一个可执行文件。
链接涉及了编译、链接和库的内容，以及操作系统一些很底层的内容。

## 2.2 编译器做了什么










































































