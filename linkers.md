# 第一章

## 计算机的基本概念

计算机系统由软件和硬件组成。 

最主要的硬件是三个：CPU 内存 I/O

对称多处理器时代：现在的计算机的CPU都是有多个物理核心的SMP

我们见到的软件主要是application和development tools。

软件是分层的。 
操作系统内核是最底层的，其上是运行时库，然后是应用程序。

    一些重要的概念：
    application
    interface
    run-time-library
    kernel 
    driver 
    hardware

层次之间需要相互通信，这就需要接口。
接口是精心设计的，尽量保持稳定不变。
**应用层程序**编写使用的**应用程序编程接口**(API)是运行时库提供的。
**运行时库**使用的接口是操作系统提供的**系统调用**。
系统调用接口一般以**软件中断**的方式提供。
**驱动程序**是**操作系统内核**的重要组成部分。
操作系统内核使用**硬件接口**提供的服务。
硬件接口的定义决定了驱动程序如何操作硬件。
操作系统和驱动程序的开发者通过阅读**硬件规格**和**硬件编程接口标准**来编写操作系统和驱动程序。

## 操作系统

操作系统的2个主要功能：提供抽象的接口、管理系统的资源。

计算机中的资源主要是计算、存储、输入输出。

### 尽量让CPU不要空转

计算资源是不应该被浪费的。

监控程序：负责调度准备就绪的程序获得CPU使用权.
这就是多道程序调度策略，是粗糙的策略。

不分轻重缓急是不好的，于是采取主动的策略一段时间之后放弃，这就是分时系统。

    multi programing
    time sharing system
    multi tasking
    process
    preemptive

操作系统接管一切资源，应用程序以进程的方式运行在一个比操作系统权限更低的级别。

操作系统有权暂停一个进程，让另一个进程运行，这就是抢占式的内核。

### 设备驱动程序

硬件之间千差万别，应用程序的编写人员不可能直接和硬件打交道。
驱动程序屏蔽了不同硬件之间的差异，硬件被抽象为一系列的概念。

驱动程序是内核的一部分，和内核运行在同一特权级别，但是又有一定的独立性。

**文件系统**管理数据在磁盘中的存储方式，是操作系统的重要组成部分。

应用程序要读取硬盘上的数据：
应用程序向文件系统发起read系统调用，
文件系统向硬盘的驱动程序发出请求，
驱动程序向硬盘发出IO命令

发送IO命令的最常见方式是读写IO寄存器。

### 内存不够了

如何将计算机上有限的物理内存分配给多个应用程序使用。

直接使用物理内存没有实现隔离、使用的效率低、运行的时候的地址不确定。

虚拟内存解决隔离的问题：每个程序有自己独立的虚拟地址空间。
关键的问题是如何实现虚拟地址和物理地址之间的映射。

根据应用程序所需的地址空间的大小直接映射：分段。
分段解决了地址空间隔离的问题和重定位问题。
分段根据程序所需要的地址空间的大小来分割内存，这样粒度太大了，效率比较低。
根据局部性原理，我们可以以更细的粒度来对内存进行分割与映射，这就是分页。

页的大小由硬件决定，或者硬件支持多种大小的页，操作系统做出选择。

    虚拟页 virtual page
    物理页 physical page
    磁盘页 disk page

虚拟存储的实现需要硬件的支持：MMU 将虚拟地址翻译成物理地址。

### 并发与线程

软件并发执行可以发挥多核CPU的性能优势。
多线程是软件并发执行的重要方法。

线程是程序执行流的最小单元，也被成为轻量级进程。
一个进程由多个线程组成，线程共享进程的地址空间和一些进程级的资源，比如打开文件和信号。

线程私有的一些数据：局部变量，函数的参数、线程局部存储（栈、PC寄存器、线程局部存储数据）。
线程之间共享的进程的资源：全局变量，堆上的数据，函数里的静态变量，程序代码，打开的文件。

线程在SMP上运行可以实现真正的并发执行，但是线程数量多与CPU核心的数量之后就需要线程调度策略。

    thread schedule
    running
    ready
    waiting

线程通常拥有至少三种状态：运行、就绪、等待。
运行中的线程拥有一小段用于执行的时间，成为时间片。`time slice`

不同操作系统中的线程调度算法，但都融入了优先级调度和轮转法的思想。
在具有优先级的调度系统中，每个线程都有自己的优先级。

线程可以分为：IO密集型线程、CPU密集型线程。

在优先级调度下，可能会出现饿死现象。因此调度系统需要提升过长时间得不到执行的线程的优先级。

线程优先级的改变一般有三种方式：

    用户指定优先级
    根据进入等待状态的频繁程度提升或降低优先级
    长时间得不到执行的线程提升优先级

可抢占线程与不可抢占线程

线程在时间片用尽之后，被强制剥夺执行的权力是可以抢占的线程。
早期系统是不可抢占线程，好处是线程调度的时候的执行时机是确定的，可以减少安全问题。

Linux的多线程

Linux中的所有执行实体都被成为任务。
`task`概念上都类似于一个单线程的进程，具有内存空间、执行实体、文件资源。

Linux下创建新的任务的系统调用：
    
    fork 复制当前的进程。
    exec 使用新的可执行映像覆盖当前的可执行映像。
    clone 创建子进程并从指定位置开始执行。

fork产生新任务的速度非常快，因为fork并不复制原任务的内存空间，而是和原任务共享一个`写时复制`的内存空间。

线程安全

多线程程序在并发时数据的一致性非常重要。
多线程程序处于一个多变的环境之中，可访问的全局变量和堆数据随时都可能被其他的线程改变。

单指令的操作可以原子化，这样在执行的时候就不会被打断。
更复杂的数据结构需要使用锁。

为了防止多个线程同时读写一个数据而产生不可预料的后果，我们需要对数据进行同步。
同步就是在一个线程访问数据未结束的时候，其他线程不能对这个数据进行访问。

锁是一种非强制的机制，线程在访问资源之前需要获取锁，访问之后释放锁。`lock` `acquire` `release`

二元信号量是最简单的一种锁，只有2个状态：占用和非占用。
适合只能被唯一一个线程独占访问的资源。

对于允许多个线程并发访问的资源，要使用多元信号量。 `semaphore`

互斥量和二元信号量相似，但是获取和释放只能是同一个线程。`mutex`

临界区`critical section`是比互斥量更加严格的同步手段。
互斥量和信号量对系统中的所有线程都是可见的。
临界区的作用范围和可见性仅限与本进程。

对于读取很多，写入很少的资源，使用读写锁来进行同步效率更高。
对于同一个锁，读写锁有两种获取方式，共享的和独占的。

条件变量是一个类似栅栏的同步手段，可以让很多线程同时等待一个事件的发生，事件发生之后，所有的线程可以同时恢复执行。

一个函数被重入说明函数执行没有完成，被打断了。
可重入函数是重入后不会产生不良后果的函数。
一个可重入的函数可以再多线程环境下放心使用。

因为编译器和CPU的优化，即使是正确地使用锁，也不一定能保证线程安全。

#### 多线程的内部情况

线程的并发执行是多处理器或操作系统调度来实现的。

用户态的线程和内核线程不是简单的一一对应的关系。

最简单的模型是一对一模型，线程之间的并发也是真正的并发。
Linux中使用clone系统调用创建的线程就是一对一的线程。

多对一的线程模型是将多个用户线程映射到同一个内核线程上。
线程之间的切换由用户代码来执行，切换的速度比一对一线程模型要快得多。
多对一模型减小了上下文切换的开销，提供了近乎无限的线程数量。
但是一个用户进程的阻塞就会造成多个进程的阻塞，增加处理器核的数量也不会对性能提升带来明显帮助。

多对多模型结合了一对一和多对一的特点。



















































































